// This client was generated by Platformatic from an OpenAPI specification.

import type { Api } from './api-types'
import type * as Types from './api-types'

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}
// The additional parameters you want to pass to the `fetch` instance.
let defaultFetchParams = {}
const defaultJsonType = { 'Content-type': 'application/json; charset=utf-8' }

function sanitizeUrl(url: string) : string {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
export const setBaseUrl = (newUrl: string) : void => { baseUrl = sanitizeUrl(newUrl) }

export const setDefaultHeaders = (headers: object): void => { defaultHeaders = headers }

export const setDefaultFetchParams = (fetchParams: RequestInit): void => { defaultFetchParams = fetchParams }

type JSON = Record<string, unknown>
/* @ts-ignore - potential unused variable */
function headersToJSON(headers: Headers): JSON {
  const output: JSON = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

const _getAgentsConfigs = async (url: string, request: Types.GetAgentsConfigsRequest): Promise<Types.GetAgentsConfigsResponses> => {
  const queryParameters: (keyof NonNullable<Types.GetAgentsConfigsRequest['query']>)[] = ['limit', 'offset', 'totalCount', 'cursor', 'startAfter', 'endBefore', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.instructions.eq', 'where.instructions.neq', 'where.instructions.gt', 'where.instructions.gte', 'where.instructions.lt', 'where.instructions.lte', 'where.instructions.like', 'where.instructions.ilike', 'where.instructions.in', 'where.instructions.nin', 'where.instructions.contains', 'where.instructions.contained', 'where.instructions.overlaps', 'where.model.eq', 'where.model.neq', 'where.model.gt', 'where.model.gte', 'where.model.lt', 'where.model.lte', 'where.model.like', 'where.model.ilike', 'where.model.in', 'where.model.nin', 'where.model.contains', 'where.model.contained', 'where.model.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.instructions', 'orderby.model', 'orderby.name', 'orderby.updatedAt']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const headers: HeadersInit = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/agentsConfigs/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const getAgentsConfigs: Api['getAgentsConfigs'] = async (request: Types.GetAgentsConfigsRequest): Promise<Types.GetAgentsConfigsResponses> => {
  return await _getAgentsConfigs(baseUrl, request)
}
const _createAgentsConfig = async (url: string, request: Types.CreateAgentsConfigRequest): Promise<Types.CreateAgentsConfigResponses> => {
  const queryParameters: (keyof NonNullable<Types.CreateAgentsConfigRequest['query']>)[] = ['fields']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const body = 'body' in request ? (request.body) : undefined
  const isFormData = body instanceof FormData
  const headers: HeadersInit = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/agentsConfigs/?${searchParams.toString()}`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const createAgentsConfig: Api['createAgentsConfig'] = async (request: Types.CreateAgentsConfigRequest): Promise<Types.CreateAgentsConfigResponses> => {
  return await _createAgentsConfig(baseUrl, request)
}
const _updateAgentsConfigs = async (url: string, request: Types.UpdateAgentsConfigsRequest): Promise<Types.UpdateAgentsConfigsResponses> => {
  const queryParameters: (keyof NonNullable<Types.UpdateAgentsConfigsRequest['query']>)[] = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.instructions.eq', 'where.instructions.neq', 'where.instructions.gt', 'where.instructions.gte', 'where.instructions.lt', 'where.instructions.lte', 'where.instructions.like', 'where.instructions.ilike', 'where.instructions.in', 'where.instructions.nin', 'where.instructions.contains', 'where.instructions.contained', 'where.instructions.overlaps', 'where.model.eq', 'where.model.neq', 'where.model.gt', 'where.model.gte', 'where.model.lt', 'where.model.lte', 'where.model.like', 'where.model.ilike', 'where.model.in', 'where.model.nin', 'where.model.contains', 'where.model.contained', 'where.model.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const body = 'body' in request ? (request.body) : undefined
  const isFormData = body instanceof FormData
  const headers: HeadersInit = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/agentsConfigs/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const updateAgentsConfigs: Api['updateAgentsConfigs'] = async (request: Types.UpdateAgentsConfigsRequest): Promise<Types.UpdateAgentsConfigsResponses> => {
  return await _updateAgentsConfigs(baseUrl, request)
}
const _getAgentsConfigById = async (url: string, request: Types.GetAgentsConfigByIdRequest): Promise<Types.GetAgentsConfigByIdResponses> => {
  const queryParameters: (keyof NonNullable<Types.GetAgentsConfigByIdRequest['query']>)[] = ['fields']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const headers: HeadersInit = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/agentsConfigs/${request.path['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const getAgentsConfigById: Api['getAgentsConfigById'] = async (request: Types.GetAgentsConfigByIdRequest): Promise<Types.GetAgentsConfigByIdResponses> => {
  return await _getAgentsConfigById(baseUrl, request)
}
const _updateAgentsConfig = async (url: string, request: Types.UpdateAgentsConfigRequest): Promise<Types.UpdateAgentsConfigResponses> => {
  const queryParameters: (keyof NonNullable<Types.UpdateAgentsConfigRequest['query']>)[] = ['fields']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const body = 'body' in request ? (request.body) : undefined
  const isFormData = body instanceof FormData
  const headers: HeadersInit = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/agentsConfigs/${request.path['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const updateAgentsConfig: Api['updateAgentsConfig'] = async (request: Types.UpdateAgentsConfigRequest): Promise<Types.UpdateAgentsConfigResponses> => {
  return await _updateAgentsConfig(baseUrl, request)
}
const _deleteAgentsConfigs = async (url: string, request: Types.DeleteAgentsConfigsRequest): Promise<Types.DeleteAgentsConfigsResponses> => {
  const queryParameters: (keyof NonNullable<Types.DeleteAgentsConfigsRequest['query']>)[] = ['fields']
  const searchParams = new URLSearchParams()
  if (request.query) {
    queryParameters.forEach((qp) => {
      const queryValue = request.query?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request.query?.[qp]
    })
  }

  const body = 'body' in request ? (request.body) : undefined
  const isFormData = body instanceof FormData
  const headers: HeadersInit = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/agentsConfigs/${request.path['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const jsonResponses = [200]
  if (jsonResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const deleteAgentsConfigs: Api['deleteAgentsConfigs'] = async (request: Types.DeleteAgentsConfigsRequest): Promise<Types.DeleteAgentsConfigsResponses> => {
  return await _deleteAgentsConfigs(baseUrl, request)
}
const _getExample = async (url: string, request: Types.GetExampleRequest): Promise<Types.GetExampleResponses> => {
  const headers: HeadersInit = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/example`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status as 200,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status as 200,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

export const getExample: Api['getExample'] = async (request: Types.GetExampleRequest): Promise<Types.GetExampleResponses> => {
  return await _getExample(baseUrl, request)
}
type BuildOptions = {
  headers?: object
}
export default function build (url: string, options?: BuildOptions) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getAgentsConfigs: _getAgentsConfigs.bind(url, ...arguments),
    createAgentsConfig: _createAgentsConfig.bind(url, ...arguments),
    updateAgentsConfigs: _updateAgentsConfigs.bind(url, ...arguments),
    getAgentsConfigById: _getAgentsConfigById.bind(url, ...arguments),
    updateAgentsConfig: _updateAgentsConfig.bind(url, ...arguments),
    deleteAgentsConfigs: _deleteAgentsConfigs.bind(url, ...arguments),
    getExample: _getExample.bind(url, ...arguments)
  }
}